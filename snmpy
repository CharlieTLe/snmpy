#!/usr/bin/env python

import argparse
import bisect
import glob
import logging
import logging.handlers
import os
import signal
import snmpy
import sys
import yaml

def create_log(logger=None, debug=False):
    log = logging.getLogger()
    if len(log.handlers) > 0:
        log.removeHandler(log.handlers[0]) # remove default stderr logger

    if logger or debug:
        if logger and logger.startswith('syslog:'):
            log_hdlr = logging.handlers.SysLogHandler(facility=logger.split(':')[-1])
        elif logger and not logger.startswith('console:'):
            log_hdlr = logging.FileHandler(logger)
        else:
            log_hdlr = logging.StreamHandler()

        log_hdlr.setFormatter(logging.Formatter('%(asctime)s.%(msecs)03d - %(filename)16s:%(lineno)-3d %(levelname)8s: %(message)s', '%Y-%m-%d %H:%M:%S'))

        log.setLevel(logging.DEBUG if debug else logging.INFO)
        log.addHandler(log_hdlr)

        log.info('logging started')
    else:
        log.addHandler(logging.NullHandler())

    return log

'''
def delete_pid(*args, **kwargs):
    try:
        if hasattr(delete_pid, 'pidfile'):
            log.debug('removing pidfile: %s', delete_pid.pidfile)
            os.remove(delete_pid.pidfile)
    finally:
        os._exit(kwargs.get('exit_code', 1))

def create_pid(pidfile, restart=False):
    if restart:
        try:
            os.kill(int(open(pidfile).readline()), signal.SIGTERM)
            sys.exit(0)
        except Exception as e:
            log.error('process not killed: %s', e)
            sys.exit(1)
    elif os.path.exists(pidfile):
        log.debug('%s exists' % pidfile)
        try:
            os.kill(int(open(pidfile).readline()), 0)
            log.error('snmpy process is running')
        except OSError:
            os.remove(pidfile)
            log.debug('removed orphaned pidfile')
        else:
            sys.exit(1)

    delete_pid.pidfile = pidfile
    open(pidfile, 'w').write('%d\n' % os.getpid())
    log.debug('wrote pidfile: %s (%d)', pidfile, os.getpid())
'''

def parse_conf(parser):
    try:
        args = parser.parse_args()
        conf = yaml.load(open(args.cfgfile))

        parser.set_defaults(**(conf['snmpy_global']))

        args = parser.parse_args()
        conf['snmpy_global'].update(vars(args))
    except (IOError, yaml.parser.ParserError, yaml.scanner.ScannerError) as e:
        parser.error('cannot parse configuration file: %s' % e)

    if conf['snmpy_global']['include_dir']:
        for item in glob.glob('%s/*.y*ml' % conf['snmpy_global']['include_dir']):
            try:
                indx, name = os.path.splitext(os.path.basename(item))[0].split('_', 1)
                if name in conf:
                    raise ValueError('%s: plugin name already assigned at another index', name)
                if int(indx) < 1:
                    raise ValueError('%s: invalid plugin index', indx)
                if int(indx) in list(v['snmpy_index'] for k, v in conf.items() if k != 'snmpy_global'):
                    raise ValueError('%s: index already assigned to another plugin', indx)

                conf[name] = {
                    'snmpy_index':   int(indx),
                    'snmpy_extra':   dict(args.extra),
                    'snmpy_datadir': args.datadir,
                    'snmpy_collect': args.collect,
                }
                conf[name].update(yaml.load(open(item)))
            except (IOError, yaml.parser.ParserError, yaml.scanner.ScannerError) as e:
                parser.error('cannot parse configuration file: %s' % e)

    return conf

'''
def build_conf(name, info, path, items=[]):
    conf = {'name': name, 'info':info, 'path': path, 'objects': {}}
    for item in items:
        key = item[0].split('.')
        if unicode(key[-1]).isnumeric():
            idx = int(key[-1])
            if conf['objects'].has_key(idx):
                conf['objects'][idx][key[0]] = item[1]
            else:
                conf['objects'][idx] = {key[0]: item[1]}
        else:
            conf[item[0]] = item[1]

    return conf
'''

def initialize(conf):
    log.info('initialization started')

    try:
        keys = [i for i in sorted(conf.keys()) if i != 'snmpy_global']
        log.info('configuring %d table(s): %s', len(keys), ', '.join(keys))

        plugins = { 0: snmpy.plugin('loaded_modules') }
        plugins[0].data['0.0'] = 'string', snmpy.__version__

        for name in keys:
            base = conf[name]['module']
            full = 'snmpy.%s' % base

            if full not in sys.modules:
                __import__(full)
                log.debug('importing module %s', full)

            plugins[0].data['1.%d' % conf[name]['snmpy_index']] = 'string', name
            log.debug('%s: added plugin at index %d', name, conf[name]['snmpy_index'])

            plugins[conf[name]['snmpy_index']] = getattr(sys.modules[full], base)(name, conf[name])
            log.debug('%s: created plugin instance of %s (%s)', name, base, plugins[conf[name]['snmpy_index']])

    except Exception as e:
        snmpy.log_exc(e, 'initialization failed')
        sys.exit(1)

    log.info('initialization complete')
    return plugins

def enter_loop(mods, base):
    log.info('command loop started for base oid %s', base)

#    signal.signal(signal.SIGTERM, delete_pid)

    sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', False)
    log.debug('stdout set unbuffered')

    keys = sorted(mods)
    while True:
        try:
            req = sys.stdin.readline().strip()
            if req == 'PING':
                print 'PONG'
                continue
            if req == 'set':
                sys.stdin.readline() # type
                sys.stdin.readline() # value
                print 'not-writable'
                continue
            if not req and not sys.stdin.isatty():
                raise SystemExit('eof')
            if not req or (req != 'get' and req != 'getnext'):
                raise ValueError('invalid request: %s' % req.strip())

            oid = sys.stdin.readline().strip()
            log.info('received %s request for %s', req, oid)

            top, sep, bot = oid.partition(base)
            log.debug('partitioned oid: %s / %s / %s', top, sep, bot)

            if sep != base:
                raise ValueError('invalid request: %s: %s' % (req, oid))

            if req == 'get':
                mod, obj = bot.lstrip('.').split('.', 1)
                key, (vtype, vdata) = mods[int(mod)].member(obj)
            elif req == 'getnext':
                prt = bot.lstrip('.').split('.', 1)
                mod = keys[0] if prt[0] == '' else int(prt[0])
                obj = '' if len(prt) < 2 else prt[1]

                idx = bisect.bisect_left(keys, mod) if mod in mods else bisect.bisect_right(keys, mod)
                while True:
                    if idx < len(keys):
                        mod = keys[idx]
                    else:
                        log.debug('end of mods')
                        raise snmpy.ReachedLastModError

                    try:
                        key, (vtype, vdata) = mods[mod].member(obj, True)
                        break
                    except snmpy.ReachedLastKeyError:
                        obj = ''
                        idx = bisect.bisect_right(keys, mod)

            log.debug('mod: %s, key: %s: val: %s/%s', mod, obj, vtype, vdata)
            print '%s.%s.%s' % (base, mod, key)
            print vtype
            print vdata

        except SystemExit as e:
            log.error(e)
            sys.exit(1)
        except KeyboardInterrupt:
            log.info('caught user interrupt, exiting')
            sys.exit(0)
        except snmpy.ReachedLastModError:
            print 'NONE'
        except Exception as e:
            snmpy.log_exc(e)
            if req == 'getnext':
                idx = bisect.bisect_right(keys, mod)
                if idx < len(keys):
                    print '%s.%s' % (base, keys[idx])
                    print 'string'
                    print 'error: %s' % e
                else:
                    print 'NONE'
            else:
                print 'NONE'

    log.info('command loop complete')

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='net-snmp pluggable module system')
    parser.add_argument('-b', '--baseoid', default=None,
                        help='base oid as configured in pass_persist by snmpd.conf')
    parser.add_argument('-f', '--cfgfile', default='/etc/snmpy.yml',
                        help='snmpy configuration file')
    parser.add_argument('-i', '--datadir', default=None,
                        help='location for offline collector data')
    parser.add_argument('-l', '--logfile', default=None,
                        help='log to file, console:, or syslog:<facility>')
    parser.add_argument('-p', '--pidfile', default=None,
                        help='pid file destination path')
    parser.add_argument('-s', '--collect', default=False, const=True, nargs='?', choices=['force'],
                        help='run offline collector scripts')
    parser.add_argument('-v', '--verbose', default=False, action='store_true',
                        help='enable basic logging')
    parser.add_argument('-r', '--destroy', default=False, action='store_true',
                        help='kill existing process saved in pidfile if exists')
    parser.add_argument('-e', '--extra', default=[], action='append', nargs=2,
                        help='extra arbitrary facts for use in plugins')

    cfg = parse_conf(parser)
    log = create_log(cfg['snmpy_global']['logfile'], cfg['snmpy_global']['verbose'])

    plugins = initialize(cfg)
    if not cfg['snmpy_global']['collect']:
        enter_loop(plugins, cfg['snmpy_global']['baseoid'])
    else:
        log.debug('collection scripts completed')


'''
    log = create_log(args.logfile, args.verbose, args.debug)
    try:
        conf, info = parse_conf(args)
        mods = initialize(conf, info, args.libpath, args.scripts)

        if not args.scripts:
            if not args.pidfile:
                parser.error('no pidfile provided in args or configuration')

            create_pid(args.pidfile, args.killpid)

            if not args.baseoid:
                parser.error('no baseoid provided in args or configuration')

            enter_loop(mods, args.baseoid)
        else:
            # wait for threads
            log.debug('scripts completed')
            sys.exit(0)
    except SystemExit as e:
        log.info('snmpy exiting: %s', e)
        delete_pid(exit_code=e.code)
'''

# vim: sw=4 ts=4 sts=4 sta si et nu ruler cinwords=if,elif,else,for,while,try,except,finally,def,class
