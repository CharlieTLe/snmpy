#!/usr/bin/env python

import ConfigParser
import bisect
import glob
import logging
import logging.handlers
import os
import signal
import snmpy
import sys

def create_log(logfile=None, verbose=False, debug=False):
    log = logging.getLogger()
    if logfile or verbose or debug:
        if logfile and logfile.startswith('syslog:'):
            log_hdlr = logging.handlers.SysLogHandler(facility=logfile.split(':')[-1])
        elif logfile and not logfile.startswith('console:'):
            log_hdlr = logging.FileHandler(logfile)
        else:
            log_hdlr = logging.StreamHandler()

        log_hdlr.setFormatter(logging.Formatter('%(asctime)s.%(msecs)03d - %(module)-16s %(funcName)12s:%(lineno)-3d - %(levelname)10s: %(message)s', '%Y-%m-%d %H:%M:%S'))

        log.setLevel(logging.DEBUG if debug else logging.INFO)
        log.addHandler(log_hdlr)

        log.info('logging started')
    else:
        log.addHandler(logging.NullHandler())

    return log

def delete_pid(*args, **kwargs):
    try:
        if hasattr(delete_pid, 'pidfile'):
            log.debug('removing pidfile: %s', delete_pid.pidfile)
            os.remove(delete_pid.pidfile)
    finally:
        os._exit(kwargs.get('exit_code', 1))

def create_pid(path, kill=False):
    if kill:
        try:
            os.kill(int(open(args.pidfile).readline()), signal.SIGTERM)
            sys.exit(0)
        except Exception as e:
            log.error('process not killed: %s', e)
            sys.exit(1)
    elif os.path.exists(args.pidfile):
        log.debug('%s exists' % args.pidfile)
        try:
            os.kill(int(open(args.pidfile).readline()), 0)
            log.error('snmpy process is running')
        except OSError:
            os.remove(args.pidfile)
            log.debug('removed orphaned pidfile')
        else:
            sys.exit(1)

    delete_pid.pidfile = path
    open(path, 'w').write('%d\n' % os.getpid())
    log.debug('wrote pidfile: %s (%d)', path, os.getpid())

def parse_conf(args):
    conf = ConfigParser.SafeConfigParser()
    conf.read(args.cfgfile)

    if conf.has_option('snmpy_global', 'include_dir'):
        conf.read([args.cfgfile] + glob.glob('%s/*.cfg' % conf.get('snmpy_global', 'include_dir')))

    if conf.has_option('snmpy_global', 'lib_path'):
        args.libpath = args.libpath or conf.get('snmpy_global', 'lib_path')

    if conf.has_option('snmpy_global', 'log_path'):
        args.logfile = args.logfile or conf.get('snmpy_global', 'log_path')

    if conf.has_option('snmpy_global', 'pid_path'):
        args.pidfile = args.pidfile or conf.get('snmpy_global', 'pid_path')

    if conf.has_option('snmpy_global', 'base_oid'):
        args.baseoid = args.baseoid or conf.get('snmpy_global', 'base_oid')

    if conf.has_section('snmpy_global'):
        conf.remove_section('snmpy_global')

    return conf

def build_conf(name, path, items=[]):
    conf = {'name': name, 'path': path, 'objects': {}}
    for item in items:
        key = item[0].split('.')
        if unicode(key[-1]).isnumeric():
            idx = int(key[-1])
            if conf['objects'].has_key(idx):
                conf['objects'][idx][key[0]] = item[1]
            else:
                conf['objects'][idx] = {key[0]: item[1]}
        else:
            conf[item[0]] = item[1]

    return conf

def initialize(conf, path, scripts):
    log.info('initialization started')

    try:
        log.info('configuring %d table(s): %s', len(conf.sections()), ', '.join(conf.sections()))

        mods = {
            0: snmpy.plugin(build_conf('loaded_modules', path), scripts)
        }
        for name in conf.sections():
            indx = conf.getint(name, 'index')
            args = build_conf(name, path, conf.items(name))
            base = conf.get(name, 'module')
            full = 'snmpy.%s' % base

            if indx < 1:
                log.warning('plugin %s has invalid index %d', name, indx)
                continue

            if full not in sys.modules:
                __import__(full)
                log.debug('importing module %s', full)

            mods[0].data['1.%d' % indx] = 'string', name
            log.debug('added plugin %s to module list at index %d', name, indx)

            mods[indx] = getattr(sys.modules[full], base)(args, scripts)
            log.debug('created plugin %s instance of %s (%s)', name, base, mods[indx])

    except Exception as e:
        snmpy.log_exc(e, 'initialization failed')
        sys.exit(1)

    log.info('initialization complete')
    return mods

def enter_loop(conf, base):
    log.info('command loop started')

    signal.signal(signal.SIGTERM, delete_pid)

    sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', False)
    log.debug('stdout set unbuffered')

    keys = sorted(mods)
    while True:
        try:
            req = sys.stdin.readline().strip()
            if req == 'PING':
                print 'PONG'
                continue
            if req == 'set':
                sys.stdin.readline() # type
                sys.stdin.readline() # value
                print 'not-writable'
                continue
            if req and req != 'get' and req != 'getnext':
                raise ValueError('invalid request: %s' % req.strip())
            if not req and not sys.stdin.isatty():
                raise SystemExit('eof')

            oid = sys.stdin.readline().strip()
            log.info('received %s request for %s', req, oid)

            top, sep, bot = oid.partition(base)
            log.debug('partitioned oid: %s / %s / %s', top, sep, bot)

            if req == 'get':
                mod, obj = bot.lstrip('.').split('.', 1)

                key, (vtype, vdata) = mods[int(mod)].member(obj)
            elif req == 'getnext':
                prt = bot.lstrip('.').split('.', 1)
                mod = keys[0] if prt[0] == '' else int(prt[0])
                obj = '' if len(prt) < 2 else prt[1]

                try:
                    key, (vtype, vdata) = mods[mod].member(obj, True)
                except IndexError:
                    mod = bisect.bisect_right(keys, mod)
                    obj = ''
                    if mod in mods:
                        key, (vtype, vdata) = mods[mod].member(obj, True)
                    else:
                        raise

            log.debug('mod: %s, key: %s: val: %s/%s', mod, obj, vtype, vdata)
            print '%s.%s.%s' % (base, mod, key)
            print vtype
            print vdata

        except IndexError as e:
            log.info('%s: end of tree', req)
        except KeyboardInterrupt:
            log.info('caught user interrupt, exiting')
            sys.exit(0)
        except SystemExit as e:
            log.error(e)
            sys.exit(1)
        except Exception as e:
            snmpy.log_exc(e)
            print 'NONE'

    log.info('command loop complete')

if __name__ == '__main__':
    import argparse

    parser = argparse.ArgumentParser(description='net-snmp pluggable module system')
    parser.add_argument('-b', '--baseoid', default=None,
                        help='base oid as configured in pass_persist by snmpd.conf')
    parser.add_argument('-f', '--cfgfile', default='/etc/snmpy.cfg',
                        help='snmpy configuration file')
    parser.add_argument('-i', '--libpath', default=None,
                        help='location for offline collector data')
    parser.add_argument('-l', '--logfile', default=None,
                        help='file path, console:, or syslog:<facility>')
    parser.add_argument('-p', '--pidfile', default=None,
                        help='pid file destination path')
    parser.add_argument('-s', '--scripts', default=False, action='store_true',
                        help='run offline collector scripts')
    parser.add_argument('-k', '--killpid', default=False, action='store_true',
                        help='kill existing process saved in pidfile if exists')
    parser.add_argument('-v', '--verbose', default=False, action='store_true',
                        help='enable basic logging')
    parser.add_argument('-d', '--debug', default=False, action='store_true',
                        help='enable debug logging')
    args = parser.parse_args()

    log = create_log(args.logfile, args.verbose, args.debug)
    try:
        conf = parse_conf(args)
        mods = initialize(conf, args.libpath, args.scripts)

        if not args.scripts:
            if not args.pidfile:
                parser.error('no pidfile provided in args or configuration')

            create_pid(args.pidfile, args.killpid)

            if not args.baseoid:
                parser.error('no baseoid provided in args or configuration')

            enter_loop(mods, args.baseoid)
        else:
            # wait for threads
            log.debug('scripts completed')
            sys.exit(0)
    except SystemExit as e:
        log.info('snmpy exiting: %s', e)
        delete_pid(exit_code=e.code)

# vim: sw=4 ts=4 sts=4 sta si et nu ruler cinwords=if,elif,else,for,while,try,except,finally,def,class
