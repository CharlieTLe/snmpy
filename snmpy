#!/usr/bin/env python

import argparse
import bisect
import importlib
import logging
import os
import snmpy
import sys

def initialize(conf):
    logging.info('initialization started')

    try:
        keys = [i for i in sorted(conf.keys()) if i != 'snmpy_global']
        logging.info('configuring %d table(s): %s', len(keys), ', '.join(keys))

        plugins = { 0: snmpy.plugin('loaded_modules') }
        plugins[0].data['0.0'] = 'string', snmpy.__version__

        for name in keys:
            base = conf[name]['module']
            full = 'snmpy.%s' % base
            code = importlib.import_module(full)

            plugins[0].data['1.%d' % conf[name]['snmpy_index']] = 'string', name
            logging.info('%s: added plugin at index %d', name, conf[name]['snmpy_index'])

            plugins[conf[name]['snmpy_index']] = getattr(code, base)(name, conf[name])
            logging.debug('%s: created plugin instance of %s (%s)', name, base, plugins[conf[name]['snmpy_index']])

    except Exception as e:
        snmpy.log_error(e, 'initialization failed')
        sys.exit(1)

    logging.info('initialization complete')
    return plugins

def enter_loop(mods, base):
    logging.info('command loop started for base oid %s', base)

    sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', False)
    logging.debug('stdout set unbuffered')

    keys = sorted(mods)
    while True:
        try:
            req = sys.stdin.readline().strip()
            if req == 'PING':
                print 'PONG'
                continue
            if req == 'set':
                sys.stdin.readline() # type
                sys.stdin.readline() # value
                print 'not-writable'
                continue
            if not req and not sys.stdin.isatty():
                raise SystemExit('eof')
            if not req or (req != 'get' and req != 'getnext'):
                raise ValueError('invalid request: %s' % req.strip())

            oid = sys.stdin.readline().strip()
            logging.info('received %s request for %s', req, oid)

            top, sep, bot = oid.partition(base)
            logging.debug('partitioned oid: %s / %s / %s', top, sep, bot)

            if sep != base:
                raise ValueError('invalid request: %s: %s' % (req, oid))

            if req == 'get':
                mod, obj = bot.lstrip('.').split('.', 1)
                key, (vtype, vdata) = mods[int(mod)].member(obj)
            elif req == 'getnext':
                prt = bot.lstrip('.').split('.', 1)
                mod = keys[0] if prt[0] == '' else int(prt[0])
                obj = '' if len(prt) < 2 else prt[1]

                idx = bisect.bisect_left(keys, mod) if mod in mods else bisect.bisect_right(keys, mod)
                while True:
                    if idx < len(keys):
                        mod = keys[idx]
                    else:
                        logging.debug('end of mods')
                        raise snmpy.ReachedLastModError

                    try:
                        key, (vtype, vdata) = mods[mod].member(obj, True)
                        break
                    except snmpy.ReachedLastKeyError:
                        obj = ''
                        idx = bisect.bisect_right(keys, mod)

            logging.debug('mod: %s, key: %s: val: %s/%s', mod, obj, vtype, vdata)
            print '%s.%s.%s' % (base, mod, key)
            print vtype
            print vdata

        except SystemExit as e:
            logging.error(e)
            sys.exit(1)
        except KeyboardInterrupt:
            logging.info('caught user interrupt, exiting')
            sys.exit(0)
        except snmpy.ReachedLastModError:
            print 'NONE'
        except Exception as e:
            snmpy.log_error(e)
            if req == 'getnext':
                idx = bisect.bisect_right(keys, mod)
                if idx < len(keys):
                    print '%s.%s' % (base, keys[idx])
                    print 'string'
                    print 'error: %s' % e
                else:
                    print 'NONE'
            else:
                print 'NONE'

    logging.info('command loop complete')

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='net-snmp pluggable module system')
    parser.add_argument('-b', '--baseoid', default=None,
                        help='base oid as configured in pass_persist by snmpd.conf')
    parser.add_argument('-f', '--cfgfile', default='/etc/snmpy.yml',
                        help='snmpy configuration file')
    parser.add_argument('-i', '--datadir', default=None,
                        help='location for offline collector data')
    parser.add_argument('-p', '--runport', default=1123, type=int,
                        help='runtime lock and api http port')
    parser.add_argument('-s', '--collect', default=False, const=True, nargs='?', choices=['force'],
                        help='run offline collector scripts')
    parser.add_argument('-l', '--logfile', default=None,
                        help='log to file, console:, or syslog:<facility>')
    parser.add_argument('-v', '--verbose', default=False, action='store_true',
                        help='enable basic logging')
    parser.add_argument('-e', '--extra', default=[], action='append', nargs=2,
                        help='extra arbitrary facts for use in plugins')
    conf = snmpy.parse_conf(parser)

    pipe = snmpy.start_server(conf['snmpy_global']['runport'])
    mods = initialize(conf)
    if not conf['snmpy_global']['collect']:
        enter_loop(mods, conf['snmpy_global']['baseoid'])
    else:
        logging.debug('collection scripts completed')

# vim: sw=4 ts=4 sts=4 sta si et nu ruler cinwords=if,elif,else,for,while,try,except,finally,def,class
